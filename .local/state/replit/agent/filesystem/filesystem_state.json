{"file_contents":{"attached_assets/app_1758543862056.py":{"content":"\"\"\"\nImproved YouTube downloader Flask app with playlist support and QR codes.\n\"\"\"\n\nimport os\nimport io\nimport uuid\nimport time\nimport base64\nimport socket\nimport shutil\nimport threading\nimport urllib.parse\nfrom typing import Any, Dict, List, Optional\nfrom glob import glob\nfrom datetime import datetime\n\nfrom flask import Flask, request, jsonify, send_file, send_from_directory, render_template\nimport yt_dlp\nimport qrcode\nimport logging\nimport zipfile\nimport subprocess\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = Flask(__name__)\n\n# In-memory job store and lock\njobs: Dict[str, Dict[str, Any]] = {}\njobs_lock = threading.Lock()\n\n# Preferred server-side download root (kept outside project dir). Per-job subfolders will be created here.\nDOWNLOAD_ROOT = os.path.join(os.path.abspath(os.path.expanduser(os.getenv(\"YT_DOWNLOAD_ROOT\", \"/tmp/yt_web\"))))\nos.makedirs(DOWNLOAD_ROOT, exist_ok=True)\n\n# Detect ffmpeg/ffprobe location so yt_dlp can use it even if PATH isn't loaded\nPROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))\nRES_FFMPEG_BIN = os.path.join(PROJECT_ROOT, \"resources\", \"ffmpeg\", \"bin\")\nFFMPEG_DIR = RES_FFMPEG_BIN if os.path.isdir(RES_FFMPEG_BIN) else None\nif not FFMPEG_DIR:\n    FFMPEG_PATH = shutil.which(\"ffmpeg\")\n    FFMPEG_DIR = os.path.dirname(FFMPEG_PATH) if FFMPEG_PATH else None\n\n\ndef generate_qr_code(url):\n    \"\"\"Generate QR code as base64 data URL\"\"\"\n    try:\n        qr = qrcode.QRCode(\n            version=1,\n            error_correction=qrcode.constants.ERROR_CORRECT_L,\n            box_size=10,\n            border=4,\n        )\n        qr.add_data(url)\n        qr.make(fit=True)\n        \n        img = qr.make_image(fill_color=\"black\", back_color=\"white\")\n        buffer = io.BytesIO()\n        img.save(buffer, format='PNG')\n        buffer.seek(0)\n        \n        img_str = base64.b64encode(buffer.getvalue()).decode()\n        return f\"data:image/png;base64,{img_str}\"\n    except Exception as e:\n        logger.error(f\"Failed to generate QR code: {e}\")\n        return None\n\n\ndef resolve_base_url() -> str:\n    \"\"\"Get the base URL for downloads, preferring LAN IP for QR codes\"\"\"\n    try:\n        # When called from a request context\n        host = request.host.split(\":\")[0]\n        port = request.host.split(\":\")[1] if \":\" in request.host else \"5000\"\n        scheme = \"https\" if request.is_secure else \"http\"\n        \n        # If localhost/127.0.0.1, try to get actual LAN IP for QR codes\n        if host in (\"127.0.0.1\", \"localhost\"):\n            try:\n                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                s.connect((\"8.8.8.8\", 80))\n                ip = s.getsockname()[0]\n                s.close()\n                return f\"{scheme}://{ip}:{port}/\"\n            except Exception:\n                pass\n        \n        return request.host_url\n    except RuntimeError:\n        # When called outside request context (like in background thread)\n        # Try to determine the IP address that would be accessible from other devices\n        try:\n            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            s.connect((\"8.8.8.8\", 80))\n            ip = s.getsockname()[0]\n            s.close()\n            return f\"http://{ip}:5000/\"\n        except Exception:\n            return \"http://localhost:5000/\"\n\n\ndef get_format_selector(kind: str, resolution: Optional[str]) -> str:\n    \"\"\"Get yt-dlp format selector string - optimized for quality and performance\"\"\"\n    if kind == \"mp3\":\n        return \"bestaudio[ext=m4a]/bestaudio[ext=aac]/bestaudio[ext=mp3]/bestaudio/best\"\n    \n    max_h = None\n    if resolution:\n        digits = \"\".join(ch for ch in resolution if ch.isdigit())\n        max_h = digits if digits else None\n    \n    if max_h:\n        # Enhanced format selection prioritizing video+audio combinations\n        return (\n            f\"bestvideo[height<={max_h}][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<={max_h}][ext=mp4]+bestaudio[ext=aac]/\"\n            f\"bestvideo[height<={max_h}][ext=webm]+bestaudio[ext=webm]/bestvideo[height<={max_h}][ext=webm]+bestaudio[ext=opus]/\"\n            f\"bestvideo[height<={max_h}]+bestaudio/best[height<={max_h}][ext=mp4]/best[height<={max_h}]/\"\n            f\"bestvideo[height<={max_h}][ext=mp4]+bestaudio/bestvideo[height<={max_h}][ext=webm]+bestaudio/\"\n            f\"bestvideo[height<={max_h}]+bestaudio[ext=m4a]/bestvideo[height<={max_h}]+bestaudio[ext=aac]/\"\n            f\"worst[height<={max_h}]/worst\"\n        )\n    \n    # For best available quality with proper video+audio combination\n    return (\n        f\"bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo[ext=mp4]+bestaudio[ext=aac]/\"\n        f\"bestvideo[ext=webm]+bestaudio[ext=webm]/bestvideo[ext=webm]+bestaudio[ext=opus]/\"\n        f\"bestvideo+bestaudio/best[ext=mp4]/best/\"\n        f\"bestvideo[ext=mp4]+bestaudio/bestvideo[ext=webm]+bestaudio/\"\n        f\"bestvideo+bestaudio[ext=m4a]/bestvideo+bestaudio[ext=aac]/\"\n        f\"worst[ext=mp4]/worst\"\n    )\n\n\ndef progress_hook(d, job_id):\n    \"\"\"Progress hook for yt-dlp downloads\"\"\"\n    with jobs_lock:\n        if job_id not in jobs:\n            return\n        \n        job = jobs[job_id]\n        status = d.get('status')\n        info = d.get('info_dict') or {}\n        pl_index = info.get('playlist_index')\n        title = info.get('title')\n        filename = d.get('filename')\n        \n        # Initialize items structure for playlist tracking\n        if 'items' not in job:\n            job['items'] = {}\n        if pl_index is not None:\n            item = job['items'].setdefault(int(pl_index), {'title': title, 'progress': 0, 'status': 'queued', 'filename': None})\n            if title and not item.get('title'):\n                item['title'] = title\n            if filename:\n                item['filename'] = os.path.basename(filename)\n        \n        if status == 'downloading':\n            downloaded = d.get('downloaded_bytes', 0)\n            total = d.get('total_bytes') or d.get('total_bytes_estimate')\n            if total and total > 0:\n                percentage = (downloaded / total)\n                job['progress'] = round(percentage * 100, 2)  # Convert to percentage (0-100)\n            else:\n                job['progress'] = None\n            job['status'] = 'downloading'\n            job['eta'] = d.get('eta')\n            job['speed'] = d.get('speed')\n            if filename:\n                job['filename'] = os.path.basename(filename)\n            if pl_index is not None:\n                job['items'][int(pl_index)]['progress'] = round((d.get('downloaded_bytes', 0) / (total or 1)) * 100, 1) if total else None\n                job['items'][int(pl_index)]['status'] = 'downloading'\n        elif status == 'finished':\n            job['progress'] = 100  # Set to 100% when finished\n            job['status'] = 'processing'\n            if filename:\n                job['produced_file'] = filename\n            if pl_index is not None:\n                job['items'][int(pl_index)]['progress'] = 100\n                job['items'][int(pl_index)]['status'] = 'processing'\n        elif status == 'postprocessing':\n            if filename:\n                job['final_file'] = os.path.basename(filename)\n                job['status'] = 'processing'\n            if pl_index is not None:\n                job['items'][int(pl_index)]['status'] = 'processing'\n\n\ndef ffmpeg_bin(name: str) -> Optional[str]:\n    \"\"\"Resolve ffmpeg/ffprobe binaries.\"\"\"\n    if FFMPEG_DIR:\n        candidate = os.path.join(FFMPEG_DIR, f\"{name}.exe\") if os.name == 'nt' else os.path.join(FFMPEG_DIR, name)\n        if os.path.isfile(candidate):\n            return candidate\n    return shutil.which(name)\n\n\ndef sanitize_filename(filename):\n    \"\"\"Remove or replace problematic characters from filenames\"\"\"\n    import re\n    \n    # Replace problematic characters with underscores\n    invalid_chars = '<>:\"/\\\\|?*#!'\n    for char in invalid_chars:\n        filename = filename.replace(char, '_')\n    \n    # Remove or replace emojis and special Unicode characters\n    # Keep basic Latin, numbers, and common punctuation\n    filename = re.sub(r'[^\\w\\s\\-_\\.\\(\\)\\[\\]]', '_', filename)\n    \n    # Remove multiple consecutive underscores\n    filename = re.sub(r'_+', '_', filename)\n    \n    # Remove leading/trailing underscores and dots\n    filename = filename.strip('_.')\n    \n    # Ensure filename is not empty\n    if not filename:\n        filename = 'video'\n    \n    # Limit length to avoid filesystem issues\n    if len(filename) > 200:\n        filename = filename[:200]\n    \n    return filename\n\n\ndef transcode_to_mp4(input_path: str, output_path: str) -> bool:\n    \"\"\"Transcode or remux an input file to MP4 with H.264 video and AAC audio.\"\"\"\n    try:\n        ffmpeg = ffmpeg_bin('ffmpeg')\n        if not ffmpeg:\n            logger.error(\"FFmpeg not available for transcoding\")\n            return False\n        \n        # Check if the input file exists and is readable\n        if not os.path.isfile(input_path) or os.path.getsize(input_path) == 0:\n            logger.error(f\"Input file does not exist or is empty: {input_path}\")\n            return False\n        \n        # Initialize variables to avoid reference before assignment\n        has_video = True  # Assume has video by default\n        has_audio = True  # Assume has audio by default\n            \n        # Use ffprobe to check streams more accurately\n        ffprobe = ffmpeg_bin('ffprobe')\n        if ffprobe:\n            probe_cmd = [\n                ffprobe, '-v', 'quiet', '-print_format', 'json', '-show_streams', input_path\n            ]\n            probe_proc = subprocess.run(probe_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='ignore')\n            \n            if probe_proc.returncode == 0:\n                import json\n                try:\n                    probe_data = json.loads(probe_proc.stdout)\n                    streams = probe_data.get('streams', [])\n                    has_video = any(s.get('codec_type') == 'video' for s in streams)\n                    has_audio = any(s.get('codec_type') == 'audio' for s in streams)\n                    \n                    if not has_video:\n                        logger.error(f\"Input file does not contain video stream: {input_path}\")\n                        return False\n                        \n                    # Check if already in good format\n                    video_codec = next((s.get('codec_name') for s in streams if s.get('codec_type') == 'video'), None)\n                    audio_codec = next((s.get('codec_name') for s in streams if s.get('codec_type') == 'audio'), None)\n                    \n                    if video_codec == 'h264' and audio_codec == 'aac' and input_path.lower().endswith('.mp4'):\n                        # Already in good format, just copy\n                        shutil.copy2(input_path, output_path)\n                        return True\n                        \n                except json.JSONDecodeError:\n                    pass\n        \n        # Improved transcoding command with better performance\n        if has_audio:\n            cmd = [ffmpeg, '-y', '-i', input_path, \n                   '-c:v', 'libx264', '-pix_fmt', 'yuv420p', \n                   '-preset', 'faster', '-crf', '23',\n                   '-movflags', '+faststart', \n                   '-c:a', 'aac', '-b:a', '128k', \n                   '-avoid_negative_ts', 'make_zero',\n                   output_path]\n        else:\n            # No audio stream\n            cmd = [ffmpeg, '-y', '-i', input_path, \n                   '-c:v', 'libx264', '-pix_fmt', 'yuv420p', \n                   '-preset', 'faster', '-crf', '23',\n                   '-movflags', '+faststart', '-an',\n                   '-avoid_negative_ts', 'make_zero',\n                   output_path]\n        \n        logger.info(f\"Transcoding to MP4: {' '.join(cmd)}\")\n        \n        proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf-8', errors='ignore')\n            \n        if proc.returncode == 0 and os.path.isfile(output_path) and os.path.getsize(output_path) > 0:\n            return True\n        stderr_output = proc.stderr or \"\"\n        logger.error(f\"Transcode failed rc={proc.returncode}: {stderr_output[:500]}\")\n        return False\n    except Exception as e:\n        logger.exception(f\"Exception during MP4 transcode: {e}\")\n        return False\n\n\ndef download_worker(job_id, url, kind, resolution, selection_ids):\n    \"\"\"Worker function for downloading videos with per-job directory\"\"\"\n    try:\n        with jobs_lock:\n            if job_id not in jobs:\n                return\n            jobs[job_id]['status'] = 'starting'\n            jobs[job_id]['current_video'] = 1\n            jobs[job_id]['total_videos'] = len(selection_ids) if selection_ids else 1\n            jobs[job_id]['items'] = {}\n            jobs[job_id]['is_playlist'] = True if selection_ids else False\n        \n        # Create per-job directory\n        job_dir = os.path.join(DOWNLOAD_ROOT, job_id)\n        os.makedirs(job_dir, exist_ok=True)\n        \n        # Configure yt-dlp options with improved performance\n        format_selector = get_format_selector(kind, resolution)\n        \n        ydl_opts = {\n            'format': format_selector,\n            'outtmpl': os.path.join(job_dir, '%(title)s.%(ext)s'),\n            'progress_hooks': [lambda d: progress_hook(d, job_id)],\n            'ignoreerrors': True,\n            'prefer_ffmpeg': True,\n            'prefer_free_formats': False,\n            'continuedl': True,\n            'concurrent_fragment_downloads': 4,  # Improved performance\n            'fragment_retries': 10,\n            'retries': 10,\n            'socket_timeout': 60,\n            'http_chunk_size': 1048576,  # 1MB chunks for better speed\n            'quiet': True,\n            'no_warnings': True,\n            'extract_flat': False,\n            'noplaylist': False,\n            'writesubtitles': False,\n            'writethumbnail': False,\n            'writeinfojson': False,\n            'keepvideo': False,\n            'fixup': 'detect_or_warn',\n            'prefer_insecure': False,\n            'geo_bypass': True,\n            'sleep_interval': 0,  # Remove unnecessary delays\n            'max_sleep_interval': 1,\n            'sleep_interval_subtitles': 0,\n        }\n        \n        # For video downloads, ensure proper merging and MP4 output\n        if kind == \"mp4\":\n            if FFMPEG_DIR or shutil.which('ffmpeg'):\n                ydl_opts['merge_output_format'] = 'mp4'\n                # Add postprocessor to ensure MP4 output\n                ydl_opts['postprocessors'] = [{\n                    'key': 'FFmpegVideoConvertor',\n                    'preferedformat': 'mp4'\n                }]\n            else:\n                logger.warning(\"FFmpeg not available - using single-file formats to avoid merge issues\")\n                # Adjust format selector to prefer single-file formats when FFmpeg is missing\n                format_selector = (\n                    f\"best[ext=mp4]/best[ext=webm]/best/\"\n                    f\"worst[ext=mp4]/worst[ext=webm]/worst\"\n                )\n                ydl_opts['format'] = format_selector\n        \n        if kind == \"mp3\":\n            ydl_opts['postprocessors'] = [{\n                'key': 'FFmpegExtractAudio',\n                'preferredcodec': 'mp3',\n                'preferredquality': '192',\n            }]\n        \n        if FFMPEG_DIR:\n            ydl_opts['ffmpeg_location'] = FFMPEG_DIR\n            logger.info(f\"Using FFmpeg from: {FFMPEG_DIR}\")\n        else:\n            logger.warning(\"FFmpeg not found in resources/ffmpeg/bin or system PATH\")\n        \n        # Handle playlist selection - FIXED LOGIC\n        if selection_ids:\n            try:\n                # Convert to proper playlist indices (1-based)\n                indices = [int(x) for x in selection_ids]\n                # yt-dlp uses 1-based indexing for playlist_items\n                ydl_opts['playlist_items'] = ','.join(str(i) for i in indices)\n                logger.info(f\"Playlist items selected: {ydl_opts['playlist_items']}\")\n            except Exception as e:\n                logger.error(f\"Invalid selection IDs: {e}\")\n                # If invalid, download all\n                pass\n        \n        with yt_dlp.YoutubeDL(ydl_opts) as ydl:\n            with jobs_lock:\n                jobs[job_id]['status'] = 'downloading'\n            ydl.download([url])\n        \n        # After download, collect produced files inside job_dir\n        files = sorted(glob(os.path.join(job_dir, \"**\"), recursive=True))\n        \n        # Enhanced file filtering\n        def is_final_file(path: str) -> bool:\n            name = os.path.basename(path).lower()\n            if not os.path.isfile(path) or os.path.getsize(path) == 0:\n                return False\n            # Exclude temporary/intermediate files\n            if name.endswith(('.part', '.ytdl', '.tmp', '.temp', '.f4v', '.f4a')):\n                return False\n            if '.part.' in name or '.ytdl.' in name or '.tmp.' in name or '.temp.' in name:\n                return False\n            if name.endswith(('.jpg', '.jpeg', '.png', '.webp', '.json', '.vtt', '.srt', '.txt', '.info')):\n                return False\n            # Include video and audio formats\n            return name.endswith((\".mp4\", \".mp3\", \".m4a\", \".webm\", \".mkv\", \".avi\", \".mov\", \".flv\", \".wmv\", \".3gp\"))\n        \n        downloaded_files = [p for p in files if is_final_file(p)]\n        \n        # Enhanced video stream validation\n        def has_proper_video_stream(path: str) -> bool:\n            \"\"\"Check if file contains proper video stream\"\"\"\n            try:\n                ffprobe = ffmpeg_bin('ffprobe')\n                if not ffprobe:\n                    return True  # Assume it's good if we can't check\n                \n                cmd = [ffprobe, '-v', 'quiet', '-print_format', 'json', '-show_streams', path]\n                proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=15, encoding='utf-8', errors='ignore')\n                \n                if proc.returncode != 0:\n                    return True  # Assume it's good if probe fails\n                \n                import json\n                try:\n                    data = json.loads(proc.stdout)\n                    streams = data.get('streams', [])\n                    \n                    # Check for video stream\n                    video_streams = [s for s in streams if s.get('codec_type') == 'video']\n                    if not video_streams:\n                        return False\n                    \n                    # Check if video stream has reasonable properties\n                    video_stream = video_streams[0]\n                    width = video_stream.get('width', 0)\n                    height = video_stream.get('height', 0)\n                    \n                    # Must have reasonable dimensions\n                    return width > 0 and height > 0\n                    \n                except json.JSONDecodeError:\n                    return True  # Assume it's good if we can't parse\n                    \n            except Exception as e:\n                logger.warning(f\"Error checking video stream in {path}: {e}\")\n                return True  # Assume it's good if we can't check\n        \n        # For video downloads, validate streams\n        if kind == 'mp4':\n            valid_files = []\n            for p in downloaded_files:\n                if has_proper_video_stream(p):\n                    valid_files.append(p)\n                else:\n                    logger.warning(f\"File {p} does not contain proper video stream\")\n            downloaded_files = valid_files\n        \n        # Determine if this is a playlist based on actual downloaded files\n        with jobs_lock:\n            detected_indices = list((jobs[job_id].get('items') or {}).keys())\n            is_playlist = len(detected_indices) > 1 or len(downloaded_files) > 1\n            jobs[job_id]['is_playlist'] = is_playlist\n        \n        if not downloaded_files:\n            logger.error(f\"No suitable final files for job {job_id}\")\n            raise Exception(\"No video files were downloaded successfully. This might be due to video unavailability, region restrictions, or format compatibility issues. Please try a different video or check the URL.\")\n        \n        # Resolve base URL in the worker thread\n        base_url = resolve_base_url()\n        with jobs_lock:\n            jobs[job_id]['completed_at'] = datetime.now().isoformat()\n        \n        if is_playlist and len(downloaded_files) > 1:\n            # ZIP for playlist (multiple files)\n            zip_name = f\"{job_id}.zip\"\n            zip_path = os.path.join(job_dir, zip_name)\n            with zipfile.ZipFile(zip_path, 'w', compression=zipfile.ZIP_DEFLATED) as zf:\n                for f in downloaded_files:\n                    zf.write(f, arcname=os.path.basename(f))\n            zip_url = f\"{base_url}download/{job_id}/{zip_name}\"\n            qr_code = generate_qr_code(zip_url)\n            with jobs_lock:\n                if job_id in jobs:\n                    jobs[job_id]['files'] = [os.path.relpath(f, job_dir) for f in downloaded_files]\n                    jobs[job_id].update({\n                        'status': 'completed',\n                        'progress': 100,\n                        'filename': zip_name,\n                        'final_file': zip_name,\n                        'download_url': zip_url,\n                        'qr': qr_code,\n                    })\n        else:\n            # Single output file\n            best_file = max(downloaded_files, key=lambda p: os.path.getsize(p))\n            output_file = best_file\n            \n            # Ensure MP4 output for video downloads\n            if kind == 'mp4':\n                # Check if we need to transcode to MP4\n                if not best_file.lower().endswith('.mp4'):\n                    # Create a sanitized filename for the output\n                    base_name = os.path.splitext(os.path.basename(best_file))[0]\n                    sanitized_name = sanitize_filename(base_name) + '.mp4'\n                    mp4_out = os.path.join(job_dir, sanitized_name)\n                    \n                    logger.info(f\"Transcoding {best_file} to MP4 format\")\n                    try:\n                        ok = transcode_to_mp4(best_file, mp4_out)\n                        if ok and os.path.isfile(mp4_out) and os.path.getsize(mp4_out) > 0:\n                            output_file = mp4_out\n                            # Remove original file to save space\n                            try:\n                                os.remove(best_file)\n                            except:\n                                pass\n                            logger.info(f\"Successfully transcoded to: {sanitized_name}\")\n                        else:\n                            logger.warning(\"Transcode failed, using original file\")\n                    except Exception as e:\n                        logger.warning(f\"Transcode failed with exception: {e}, using original file\")\n            \n            filename = os.path.basename(output_file)\n            download_url = f\"{base_url}download/{job_id}/{urllib.parse.quote(filename)}\"\n            qr_code = generate_qr_code(download_url)\n            \n            with jobs_lock:\n                if job_id in jobs:\n                    jobs[job_id].update({\n                        'status': 'completed',\n                        'progress': 100,\n                        'filename': filename,\n                        'final_file': filename,\n                        'download_url': download_url,\n                        'qr': qr_code,\n                    })\n                    \n    except Exception as e:\n        logger.exception(f\"Download worker error for job {job_id}: {e}\")\n        with jobs_lock:\n            if job_id in jobs:\n                jobs[job_id].update({\n                    'status': 'error',\n                    'error': str(e),\n                    'progress': 0,\n                })\n\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n\n@app.route('/about')\ndef about():\n    return render_template('about.html')\n\n\n@app.route('/api/metadata', methods=['POST'])\ndef get_metadata():\n    \"\"\"Get video/playlist metadata\"\"\"\n    try:\n        data = request.get_json()\n        url = data.get('url', '').strip()\n        \n        if not url:\n            return jsonify({'error': 'URL is required'}), 400\n        \n        ydl_opts = {\n            'quiet': True,\n            'no_warnings': True,\n            'extract_flat': True,\n            'skip_download': True,\n        }\n        \n        with yt_dlp.YoutubeDL(ydl_opts) as ydl:\n            info = ydl.extract_info(url, download=False)\n            \n            if info.get('_type') == 'playlist':\n                # Playlist metadata\n                entries = []\n                for i, entry in enumerate(info.get('entries', [])):\n                    if entry:\n                        # Get more detailed info for each entry\n                        try:\n                            detailed_ydl_opts = {\n                                'quiet': True,\n                                'no_warnings': True,\n                                'skip_download': True,\n                            }\n                            with yt_dlp.YoutubeDL(detailed_ydl_opts) as detail_ydl:\n                                detailed_info = detail_ydl.extract_info(entry.get('url', ''), download=False)\n                                \n                                # Extract available resolutions\n                                resolutions = set()\n                                formats = detailed_info.get('formats', [])\n                                for fmt in formats:\n                                    height = fmt.get('height')\n                                    if height:\n                                        resolutions.add(f\"{height}p\")\n                                \n                                entries.append({\n                                    'title': detailed_info.get('title', entry.get('title', 'Unknown')),\n                                    'thumbnail': detailed_info.get('thumbnail', entry.get('thumbnail')),\n                                    'duration': detailed_info.get('duration', entry.get('duration')),\n                                    'resolutions': sorted(list(resolutions), key=lambda x: int(x.replace('p', '')), reverse=True) or ['720p', '480p', '360p']\n                                })\n                        except Exception as e:\n                            logger.warning(f\"Failed to get detailed info for playlist entry {i}: {e}\")\n                            entries.append({\n                                'title': entry.get('title', 'Unknown'),\n                                'thumbnail': entry.get('thumbnail'),\n                                'duration': entry.get('duration'),\n                                'resolutions': ['720p', '480p', '360p']\n                            })\n                \n                return jsonify({\n                    'type': 'playlist',\n                    'title': info.get('title', 'Playlist'),\n                    'entries': entries\n                })\n            else:\n                # Single video metadata\n                formats = info.get('formats', [])\n                resolutions = set()\n                for fmt in formats:\n                    height = fmt.get('height')\n                    if height:\n                        resolutions.add(f\"{height}p\")\n                \n                return jsonify({\n                    'type': 'video',\n                    'video': {\n                        'title': info.get('title', 'Unknown'),\n                        'thumbnail': info.get('thumbnail'),\n                        'duration': info.get('duration'),\n                        'channel': info.get('uploader', info.get('channel')),\n                        'resolutions': sorted(list(resolutions), key=lambda x: int(x.replace('p', '')), reverse=True) or ['720p', '480p', '360p']\n                    }\n                })\n                \n    except Exception as e:\n        logger.exception(f\"Metadata extraction failed: {e}\")\n        return jsonify({'error': f'Failed to extract metadata: {str(e)}'}), 500\n\n\n@app.route('/api/download', methods=['POST'])\ndef start_download():\n    \"\"\"Start a download job\"\"\"\n    try:\n        data = request.get_json()\n        url = data.get('url', '').strip()\n        kind = data.get('kind', 'mp4')\n        resolution = data.get('resolution')\n        selection_ids = data.get('selection_ids', [])\n        \n        if not url:\n            return jsonify({'error': 'URL is required'}), 400\n        \n        job_id = str(uuid.uuid4())\n        \n        with jobs_lock:\n            jobs[job_id] = {\n                'id': job_id,\n                'url': url,\n                'kind': kind,\n                'resolution': resolution,\n                'selection_ids': selection_ids,\n                'status': 'queued',\n                'progress': 0,\n                'created_at': datetime.now().isoformat(),\n            }\n        \n        # Start download in background thread\n        thread = threading.Thread(\n            target=download_worker,\n            args=(job_id, url, kind, resolution, selection_ids),\n            daemon=True\n        )\n        thread.start()\n        \n        return jsonify({'job_id': job_id})\n        \n    except Exception as e:\n        logger.exception(f\"Download start failed: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n\n@app.route('/api/progress/<job_id>')\ndef get_progress(job_id):\n    \"\"\"Get download progress\"\"\"\n    with jobs_lock:\n        job = jobs.get(job_id)\n        if not job:\n            return jsonify({'error': 'Job not found'}), 404\n        \n        # Convert items dict to list for frontend\n        items_dict = job.get('items', {})\n        items_list = []\n        for idx, item_data in items_dict.items():\n            items_list.append({\n                'index': idx,\n                'title': item_data.get('title', f'Item {idx}'),\n                'progress': item_data.get('progress', 0),\n                'status': item_data.get('status', 'queued'),\n                'filename': item_data.get('filename')\n            })\n        \n        result = {\n            'status': job.get('status'),\n            'progress': job.get('progress', 0),\n            'filename': job.get('filename'),\n            'eta': job.get('eta'),\n            'speed': job.get('speed'),\n            'total_videos': job.get('total_videos', 1),\n            'current_video': job.get('current_video', 1),\n            'is_playlist': job.get('is_playlist', False),\n            'items': items_list,\n            'download_url': job.get('download_url'),\n            'qr': job.get('qr'),\n            'error': job.get('error')\n        }\n        \n        return jsonify(result)\n\n\n@app.route('/download/<job_id>/<filename>')\ndef download_file(job_id, filename):\n    \"\"\"Download a file\"\"\"\n    try:\n        job_dir = os.path.join(DOWNLOAD_ROOT, job_id)\n        file_path = os.path.join(job_dir, filename)\n        \n        if not os.path.isfile(file_path):\n            return jsonify({'error': 'File not found'}), 404\n        \n        return send_file(file_path, as_attachment=True, download_name=filename)\n        \n    except Exception as e:\n        logger.exception(f\"Download file failed: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n\n@app.route('/static/<path:filename>')\ndef static_files(filename):\n    \"\"\"Serve static files\"\"\"\n    return send_from_directory('static', filename)\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=False)","size_bytes":31768},"attached_assets/styles_1758543879635.css":{"content":"/* Custom styles for YTDownloadX */\n\n/* Hero Section */\n.hero-section {\n    position: relative;\n    min-height: 100vh;\n    display: flex;\n    align-items: center;\n    background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);\n    overflow: hidden;\n}\n\n.hero-background {\n    position: absolute;\n    inset: 0;\n    background: linear-gradient(to bottom right, rgba(79, 70, 229, 0.05), transparent, rgba(236, 72, 153, 0.05));\n    filter: blur(120px);\n}\n\n.geometric-shape {\n    position: absolute;\n    border-radius: 50%;\n    background: linear-gradient(to right, rgba(255, 255, 255, 0.08), transparent);\n    backdrop-filter: blur(2px);\n    border: 2px solid rgba(255, 255, 255, 0.15);\n    box-shadow: 0 8px 32px rgba(255, 255, 255, 0.1);\n    animation: float 12s ease-in-out infinite;\n}\n\n.shape-1 {\n    width: 600px;\n    height: 140px;\n    left: -10%;\n    top: 15%;\n    transform: rotate(12deg);\n    background: linear-gradient(to right, rgba(79, 70, 229, 0.15), transparent);\n    animation-delay: 0s;\n}\n\n.shape-2 {\n    width: 500px;\n    height: 120px;\n    right: -5%;\n    top: 70%;\n    transform: rotate(-15deg);\n    background: linear-gradient(to right, rgba(236, 72, 153, 0.15), transparent);\n    animation-delay: 2s;\n}\n\n.shape-3 {\n    width: 300px;\n    height: 80px;\n    left: 5%;\n    bottom: 5%;\n    transform: rotate(-8deg);\n    background: linear-gradient(to right, rgba(139, 92, 246, 0.15), transparent);\n    animation-delay: 4s;\n}\n\n.shape-4 {\n    width: 200px;\n    height: 60px;\n    right: 15%;\n    top: 10%;\n    transform: rotate(20deg);\n    background: linear-gradient(to right, rgba(245, 158, 11, 0.15), transparent);\n    animation-delay: 6s;\n}\n\n.shape-5 {\n    width: 150px;\n    height: 40px;\n    left: 20%;\n    top: 5%;\n    transform: rotate(-25deg);\n    background: linear-gradient(to right, rgba(6, 182, 212, 0.15), transparent);\n    animation-delay: 8s;\n}\n\n@keyframes float {\n    0%, 100% { transform: translateY(0px) rotate(var(--rotation, 0deg)); }\n    50% { transform: translateY(-15px) rotate(var(--rotation, 0deg)); }\n}\n\n.hero-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 16px;\n    border-radius: 50px;\n    background: rgba(255, 255, 255, 0.03);\n    border: 1px solid rgba(255, 255, 255, 0.08);\n    margin-bottom: 2rem;\n    animation: fadeInUp 1s ease-out 0.5s both;\n}\n\n.badge-dot {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    background: #ef4444;\n}\n\n.hero-title {\n    font-size: clamp(2.5rem, 8vw, 6rem);\n    font-weight: 700;\n    margin-bottom: 1.5rem;\n    line-height: 1.1;\n    animation: fadeInUp 1s ease-out 0.7s both;\n}\n\n.hero-title-main {\n    background: linear-gradient(to bottom, #ffffff, rgba(255, 255, 255, 0.8));\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n    color: transparent;\n}\n\n.hero-title-gradient {\n    background: linear-gradient(to right, #a78bfa, rgba(255, 255, 255, 0.9), #fca5a5);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n    color: transparent;\n}\n\n.hero-description {\n    font-size: 1.25rem;\n    color: rgba(255, 255, 255, 0.6);\n    margin-bottom: 2rem;\n    line-height: 1.6;\n    font-weight: 300;\n    max-width: 600px;\n    margin-left: auto;\n    margin-right: auto;\n    animation: fadeInUp 1s ease-out 0.9s both;\n}\n\n.hero-cta {\n    animation: fadeInUp 1s ease-out 1.1s both;\n}\n\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(30px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n/* Features Section */\n.feature-card {\n    background: rgba(255, 255, 255, 0.02);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    border-radius: 16px;\n    padding: 2rem;\n    text-align: center;\n    transition: all 0.3s ease;\n    backdrop-filter: blur(10px);\n}\n\n.feature-card:hover {\n    transform: translateY(-5px);\n    border-color: rgba(79, 70, 229, 0.3);\n    box-shadow: 0 20px 40px rgba(79, 70, 229, 0.1);\n}\n\n.feature-icon {\n    margin-bottom: 1.5rem;\n}\n\n.star {\n    font-size: 2rem;\n    filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.3));\n}\n\n/* Navigation */\n.navbar-dark .navbar-nav .nav-link {\n    transition: color 0.3s ease;\n}\n\n.hover-text-white:hover {\n    color: #ffffff !important;\n}\n\n/* Footer */\nfooter a:hover {\n    color: #ffffff !important;\n}\n\n/* Existing styles */\n.card {\n    transition: box-shadow 0.2s ease-in-out;\n    background: rgba(255, 255, 255, 0.02);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.card:hover {\n    box-shadow: 0 8px 32px rgba(79, 70, 229, 0.1) !important;\n    border-color: rgba(79, 70, 229, 0.3);\n}\n\n.progress {\n    height: 1.5rem;\n    background: rgba(255, 255, 255, 0.1);\n}\n\n.progress-bar {\n    transition: width 0.3s ease;\n    background: linear-gradient(90deg, #6366f1, #8b5cf6);\n}\n\n#thumb {\n    max-height: 200px;\n    object-fit: cover;\n    border-radius: 8px;\n}\n\n.card-img-top {\n    height: 150px;\n    object-fit: cover;\n}\n\n#qr {\n    max-width: 200px;\n    height: auto;\n    border-radius: 8px;\n}\n\n.form-check-input:checked {\n    background-color: #6366f1;\n    border-color: #6366f1;\n}\n\n.btn {\n    transition: all 0.2s ease-in-out;\n    border-radius: 8px;\n}\n\n.btn:hover {\n    transform: translateY(-1px);\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, #6366f1, #8b5cf6);\n    border: none;\n}\n\n.btn-primary:hover {\n    background: linear-gradient(135deg, #5b5bcf, #7c3aed);\n    transform: translateY(-2px);\n    box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);\n}\n\n/* Dark theme adjustments */\n[data-bs-theme=\"dark\"] .form-control {\n    background-color: rgba(255, 255, 255, 0.05);\n    border-color: rgba(255, 255, 255, 0.1);\n    color: #fff;\n}\n\n[data-bs-theme=\"dark\"] .form-control:focus {\n    background-color: rgba(255, 255, 255, 0.08);\n    border-color: #6366f1;\n    box-shadow: 0 0 0 0.25rem rgba(99, 102, 241, 0.25);\n}\n\n[data-bs-theme=\"dark\"] .form-select {\n    background-color: rgba(255, 255, 255, 0.05);\n    border-color: rgba(255, 255, 255, 0.1);\n    color: #fff;\n}\n\n/* Loading state */\n.spinner-border-sm {\n    width: 1rem;\n    height: 1rem;\n}\n\n/* Background */\nbody {\n    background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);\n    min-height: 100vh;\n}\n\n/* About Page Styles */\n.about-hero-section {\n    position: relative;\n    min-height: 70vh;\n    display: flex;\n    align-items: center;\n    background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);\n    overflow: hidden;\n}\n\n.about-card {\n    background: rgba(255, 255, 255, 0.02);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    border-radius: 16px;\n    padding: 3rem;\n    backdrop-filter: blur(10px);\n    transition: all 0.3s ease;\n}\n\n.about-card:hover {\n    border-color: rgba(79, 70, 229, 0.3);\n    box-shadow: 0 20px 40px rgba(79, 70, 229, 0.05);\n}\n\n.feature-highlight {\n    padding: 1.5rem;\n    background: rgba(255, 255, 255, 0.02);\n    border: 1px solid rgba(255, 255, 255, 0.05);\n    border-radius: 12px;\n    transition: all 0.3s ease;\n}\n\n.feature-highlight:hover {\n    background: rgba(79, 70, 229, 0.05);\n    border-color: rgba(79, 70, 229, 0.2);\n    transform: translateY(-2px);\n}\n\n.team-card {\n    background: rgba(255, 255, 255, 0.03);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    border-radius: 12px;\n    padding: 2rem;\n    text-align: center;\n    transition: all 0.3s ease;\n    backdrop-filter: blur(10px);\n    height: 100%;\n}\n\n.team-card:hover {\n    transform: translateY(-5px);\n    border-color: rgba(79, 70, 229, 0.4);\n    box-shadow: 0 15px 35px rgba(79, 70, 229, 0.1);\n}\n\n.team-header {\n    margin-bottom: 1.5rem;\n}\n\n.team-role {\n    color: #6366f1;\n    font-size: 0.9rem;\n    font-weight: 500;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.team-contact {\n    text-align: left;\n}\n\n.contact-link {\n    color: #8b5cf6;\n    text-decoration: none;\n    transition: color 0.3s ease;\n}\n\n.contact-link:hover {\n    color: #a78bfa;\n    text-decoration: underline;\n}\n\n.cta-card {\n    background: rgba(255, 255, 255, 0.02);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    border-radius: 16px;\n    padding: 3rem;\n    backdrop-filter: blur(10px);\n}\n\n/* Responsive adjustments */\n@media (max-width: 768px) {\n    .container {\n        padding-left: 1rem;\n        padding-right: 1rem;\n    }\n    \n    .card-body {\n        padding: 1rem;\n    }\n    \n    .hero-title {\n        font-size: 2.5rem;\n    }\n    \n    .hero-description {\n        font-size: 1rem;\n    }\n    \n    .geometric-shape {\n        display: none;\n    }\n    \n    .feature-card {\n        padding: 1.5rem;\n    }\n    \n    .about-card {\n        padding: 2rem;\n    }\n    \n    .team-card {\n        padding: 1.5rem;\n    }\n    \n    .cta-card {\n        padding: 2rem;\n    }\n}","size_bytes":8685}},"version":1}